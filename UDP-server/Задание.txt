Три типа процессов:

клиент. Знает адрес и порт диспетчера, со случайной периодичностью, задаваемой в конфиге клиента, посылает диспетчеру
условное задание

диспетчер. Слушает на порту, задаваемом в конфиге диспетчера. Обрабатывает UDP-пакеты от клиентов и вычислителей.
Получая запрос от клиента - выбирает доступного вычислителя, посылает ему задание.
Получая ответ от вычислителя - возвращает ответ клиенту, инициировавшему конкретный запрос

вычислитель.
Слушает на порту, задаваемом в конфиге вычислителя. При получении задания эмулирует длительные вычисления,
засыпая на период, значение которого определяется случайным образом из интервала, задаваемого в конфиге.
По окончании паузы посылает ответ диспетчеру с условным результатом вычислений.
Вычислитель может периодически “выходить из строя”, переставая принимать запросы и отвечать диспетчеру.
Вероятность и длительность периода неработоспособности конфигурируются.
Работоспособные вычислители с заданной периодичностью посылают диспетчеру уведомления о своей доступности.
Ответ с результатом вычислений также является сигналом диспетчеру о работоспособности конкретного экземпляра вычислителя.

Требуется обеспечить динамическую регистрацию вычислителей диспетчером,
отслеживание неработоспособности отдельных вычислителей, обеспечить гарантированное выполнение запросов
(если выбранный для обработки конкретного клиентского запроса вычислитель за заданный промежуток
не ответил - диспетчер посылает запрос другому свободному вычислителю, либо держит запрос в очереди,
пока не истечет заданный таймаут).

Протокол взаимодействия между клиентом и диспетчером, а также между диспетчером и
вычислителем (формат пакетов) - на усмотрение разработчика. Ограничение - в качестве транспорта должен использоваться UDP.

Формат конфигурационных файлов - JSON.

План эксперимента - запускается диспетчер, запускается несколько процессов-вычислителей, возможно,
на разных серверах, запускается несколько клиентов. Каждый клиент ведет статистику, сколько запросов было отправлено,
сколько ответов было получено, сколько запросов осталось без ответа, а также минимальное, среднее и максимальное время получения ответа.

///////////////////////////////
a.       Хотелось бы видеть реализацию с асинхронной работой с сокетами без тредов и локов. Треды в данной реализации не нужны
2.       Задание
a.       Клиент
    +i.      Для каждого запроса создается свой сокет, хотя можно обойтись одним сокетом за все время работы.
    Вероятно, это способ сопоставления ответа запросу, но это какой-то кривой способ решения данной задачи
    + ii.      По коду не видно, как заставить клиента отправить более одного запроса – переменная COUNT не используется при вызове start(), поэтому всегда будет применяться дефолтное значение 1 для входного параметра
b.       Диспетчер
    +i.      Использование тредов и lock’ов излишне, питон сам обеспечивает безопасность работы с данными в многотредовом приложении
    ii.      Непонятно, зачем передавать адрес от вычислителя диспетчеру, когда его можно взять из сокета при получении
    пакета (при условии, конечно, что вычислитель использует один сокет для отправки признака готовности и ответа на задачу)
    +iii.      Использование return только в одной ветке у if – это некорректно. Если функция должна что-то возвращать, то хотелось бы, чтобы возвращаемое значение контролировалось кодом в любом случае
    +iv.      Последовательный вызов add_ready сначала в handle, а потом в add_turn – это некрасиво
    v.      Синхронная работа с вычислителями по отправке запроса и получению ответа, в данном месте точно хотелось бы видеть асинхронную работу с клиентами и вычислителями
c.       Вычислитель
    +i.      Зачем нужен server_sock? Не нашел, где он используется
    +ii.      Не нашел обработчик таймаутов для my_calc, хотя таймаут вставляется
    +iii.      Нет реализации искусственной неработоспособности вычислителя
    iv.      Для реализации вычислителя достаточно одного сокета
    + v.      В конфиге нет адреса диспетчера, этот адрес жестко прописан в коде вычислителя
    + vi.      Адрес вычислителя отправляется диспетчеру не из соответствующих переменных (хотя надо бы этот адрес вынести в конфиг), а из константной строки READY_MESSAGE = '("localhost", 43112);"ready"' – это жесть
d.       Общие
    i.      кодинг стайл по PEP-8 - плюс
    ii.      Каждому модулю достаточно одного сокета
    iii.      Нет асинхронной работы с сокетами
    iv.      Не все обязательные параметры задаются в конфиг-файле
    v.
